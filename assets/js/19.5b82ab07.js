(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{365:function(n,t,a){"use strict";a.r(t);var e=a(42),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"loading-加载进度条"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loading-加载进度条"}},[n._v("#")]),n._v(" loading 加载进度条")]),n._v(" "),a("p",[n._v("概述 #\n全局创建一个显示页面加载、异步请求、文件上传等的加载进度条。")]),n._v(" "),a("p",[n._v("说明 #\nLoadingBar 只会在全局创建一个，因此在任何位置调用的方法都会控制这同一个组件。主要使用场景是路由切换和 Ajax，因为这两者都不能拿到精确的进度，LoadingBar 会模拟进度，当然也可以通过 update()方法来传入一个精确的进度，比如在文件上传时会很有用，具体见 API。")]),n._v(" "),a("p",[n._v("在路由中使用 #")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// 部分代码省略\nimport hui from 'h_ui';\nVue.use(hui);\n\nrouter.beforeEach((to, from, next) => {\n    hui.hLoadingBar.start();\n    next();\n});\n\nrouter.afterEach((to, from, next) => {\n    hui.hLoadingBar.finish();\n});\n")])])]),a("p",[n._v("在异步请求中使用")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("<script>\n// 以jQuery的Ajax为例，部分代码省略\nimport $ from 'jquery';\nexport default {\n    methods: {\n        getData () {\n            this.$hLoading.start();\n            $.ajax({\n                url: '/api/someurl',\n                type: 'get',\n                success: () => {\n                    this.$hLoading.finish();\n                }\n                error: () => {\n                    this.$hLoading.error();\n                }\n            });\n        }\n    }\n}\n<\/script>\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);